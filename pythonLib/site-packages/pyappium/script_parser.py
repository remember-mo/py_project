# -*- coding: utf-8 -*-
# !/usr/bin/env python
# __author__ = 'hongkefeng'

# Copyright 2000-2017 by Koudai Corporation.
# All rights reserved.
# This software is the confidential and proprietary information of
# Koudai Corporation ("Confidential Information"). You
# shall not disclose such Confidential Information and shall use
# it only in accordance with the terms of the license agreement
# you entered into with Koudai.
import glob
import os
import clipboard
from selenium.common.exceptions import WebDriverException
from pyappium.android_uihelper import *
from pyappium.appium_client import *
from pyappium.engine import *
from pyappium.log import SimpleLog
from pyappium.utils import *
from pyappium.zeus_params import AppiumParams


class TaskInfo(object):
    device_name = ""
    package = ""
    activity = ""
    root_url = ""
    login_url = ""


class ScriptParser:
    """
    Usage:
        load a uia script, parser uia script to steps
    """

    def __init__(self, script_file):
        self.log = SimpleLog()
        self.script_file = script_file
        config_info = self.config_content()
        self.task_info = self.get_task_info(config_info=config_info)

    def config_content(self):
        """
        get task config file
        :return: config file path
        """
        with open(self.script_file, "r") as f:
            c = f.read()

        config_file = re.findall("(target_app|task_json)=([\w\W]+?)@", c)

        return config_file[0][1]

    def get_task_info(self, config_info):
        current_task = TaskInfo()
        task_info = json.loads(config_info)

        try:
            current_task.package = task_info["appName"]
        except Exception as e:
            raise CUITestException("package name not found", e.args[0])

        try:
            current_task.root_url = task_info["rootUrl"]
        except Exception as e:
            current_task.root_url = ""

        if self.script_file.endswith(Platform.Android.lower()):
            current_task.activity = task_info["startActivity"]

        return current_task

    def get_actions(self):
        """
        get each case steps
        :return:  list of cases
        """
        with open(self.script_file, "r") as f:
            c = f.read()

        config_file = re.findall("@test[\w\W]+", c)
        return [action.strip() for action in config_file[0].split("@test\n") if action]

    def show_actions(self):
        """
        Usage:
            just show each case, maybe used at debug mode
        :return:
        """
        for actions in self.get_actions():
            self.log.info("\n".join(actions))


class ScriptExecute:
    """
    Usage:
        the engine of simple script.
        execute each step according simple steps description

        support event:
            - url
            - click
            - input
            - swipe

        support platform:
            - Android
            - iOS

        Engine:
            Android/iOS execution Engine are all based Appium Client
    """

    def __init__(self, uia_script, engine, report):
        """
        :param uia_script: the uia script file path
        """
        self.engine = engine
        self.report = report

        self.uia_script = uia_script
        self.log = SimpleLog()
        self.case_steps = self.uia_script.split("\n")
        self.case_name = self.get_case_name()
        self.log.line_info("Start Execute:" + self.case_name)
        self.image_dir = os.path.join(AppiumParams.REPORT_DIR, "images", self.case_name)

        if not os.path.exists(self.image_dir):
            os.makedirs(self.image_dir)

    def script_steps(self):  # Show test case steps
        self.log.info(self.case_name)

    def get_case_name(self):
        """
        Usage:
            just get current test case name
        :return: return current test case name, if error, return ""
        """
        for step in self.case_steps:
            if step.startswith("@name"):
                return step.replace("@name=", "")
        else:
            self.log.critical("Case name not found, please check uia script")
            return ""

    def get_action_steps(self):
        """
        Usage:
            just filter not supported case description
            support the following action:
                url
                input
                click
                swipe
            if the step description is not starts with url/input/click/swipe
            it will be filtered.
        :return: return a list of the valid action steps
        """
        return [
            action
            for action in self.case_steps
            if any(
                    [action.startswith(s_action) for s_action in TaskConfig.Support_Actions]
            )
        ]

    def execute(self):
        """
        Usage:
            execute each step
        :return:
        """
        action_steps = self.get_action_steps()

        # add test case
        self.report.add_test_activity(self.case_name)

        total_ts = time.time()
        for idx, action in enumerate(action_steps):

            if action.startswith("t."):
                action = action[2:]

            try:
                self.action_adapter(action)
                sleep(2)
            except WebDriverException as e:
                self.log.error("Appium server error: " + e.args[0])
                raise WebDriverException("Appium Server Error", e.args[0])
            except Exception as e:
                print(e)
                self.log.error("无法找到控件、或其他错误: ")
                error_img = self.engine.auto_screenshot(self.image_dir, "error")
                self.report.add_test_case(
                        "failed",
                        "无法找到控件、或其他错误",
                        "10.10",
                        "无法找到控件、或其他错误" + action,
                        [
                            self.get_image_path(
                                    os.path.basename(error_img.replace(".png", ""))
                            )
                        ],
                )
            sleep(2)

        total_te = time.time()

        # combine_result = combine_images(self.image_dir)

        files = filter(os.path.isfile, glob.glob(self.image_dir + "*/*.png"))
        images_ = list(files)
        images_.sort(key=lambda x: os.path.getmtime(x))
        imgs = [
            self.get_image_path(os.path.basename(i.replace(".png", "")), True)
            for i in images_
        ]

        self.report.add_test_case(
                "passed", "全部过程", str(total_te - total_ts)[:5], "Logs", imgs
        )

    def action_adapter(self, step_text):
        """
        Usage:
            execute each step according action event string
        :param step_text:
        :return: None
        """
        if step_text.startswith("click"):
            self.click(step_text)
            return 0

        if step_text.startswith("url"):
            self.log.info("Entry URL：" + step_text)
            # self.engine.auto_screenshot(self.image_dir)
            self.url(step_text)
            return 0

        if step_text.startswith("input"):
            self.log.info("Input：" + step_text)
            self.input(step_text)
            return 0

        if step_text.startswith("info_of"):
            self.log.info("info_of：" + step_text)

            return self.engine.info_of(step_text)

        if step_text.startswith("swipe"):
            self.log.info("Swipe：" + step_text)
            # self.engine.auto_screenshot(self.image_dir)
            self.swipe(step_text)
            sleep(2)
            return 0

        if step_text.startswith("exist"):
            self.log.info(
                    "Check Element is exist: " + ", ".join(step_text[6:-1].split(","))
            )
            should_be_exist_elements = step_text[6:-1].split(",")

            image = self.engine.auto_screenshot(self.image_dir)

            for check_element in should_be_exist_elements:
                check_element.replace("/", "-").replace('"', "")
                self.engine.draw_element(image, check_element)

                ts = time.time()
                if self.engine.verify_exist(check_element):
                    self.log.info("找到控件: " + check_element)
                    result = "passed"
                    info = "找到控件：" + check_element
                else:
                    self.log.error("没有找到控件: " + check_element)
                    result = "failed"
                    info = "没有找到：" + check_element

                te = time.time()

                self.report.add_test_case(
                        result,
                        "检查 ---> {check_element} ".format(check_element=check_element),
                        str(te - ts)[:5],
                        info,
                        [self.get_image_path(os.path.basename(image.replace(".png", "")))],
                )
            return 0

        if step_text.startswith("not_exist"):
            self.log.info(
                    "Check Element not_exist: " + ", ".join(step_text[6:-1].split(","))
            )
            not_exist_imgs = self.engine.auto_screenshot(self.image_dir)
            should_be_not_exist_elements = step_text[6:-1].split(",")
            for check_element in should_be_not_exist_elements:
                check_element = check_element.replace('"', "")

                if self.engine.verify_not_exist(check_element):
                    self.log.info("没有找到控件" + check_element)
                    result = "passed"
                    info = "没有找到：" + check_element
                else:
                    self.log.error("没有找到控件: " + check_element)
                    result = "failed"
                    info = "没有找到：" + check_element

                self.report.add_test_case(
                        result,
                        "检查---> {check_element} ".format(check_element=check_element),
                        "10.0",
                        info,
                        [
                            self.get_image_path(
                                    os.path.basename(not_exist_imgs.replace(".png", ""))
                            )
                        ],
                )
            return 0

        if step_text.startswith("iclick"):
            self.engine.auto_screenshot(self.image_dir)
            maybe_exist = step_text[8:-1].split(",")
            elements = [el.replace('"', "") for el in maybe_exist]
            self.log.info("iclick: " + "|".join(maybe_exist))
            self.engine.iclick(elements, self.image_dir)
            return 0

        if step_text.startswith("restart_app"):
            self.engine.auto_screenshot(self.image_dir)
            self.log.info("restart_app")
            self.engine.restart_app()
            return 0

    def get_image_path(self, img_name, mutiple_imgs=True):
        if mutiple_imgs:
            return "./images/{case}/{img_name}.png".format(
                    case=self.case_name, img_name=img_name
            )
        else:
            return "./images/{case}/action_{img_name}.png".format(
                    case=self.case_name, img_name=img_name
            )

    def input(self, text):
        """
        Usage:
            Execute input action
        :param text: input steps text
        :return:
        """
        input_element = text[6:-1].split(",")
        input_element = [el.strip().replace('"', "") for el in input_element]
        if len(input_element) != 2:
            self.log.critical("Error Input Syntax --->" + text)
        else:
            self.engine.draw_element(
                    self.engine.auto_screenshot(self.image_dir), input_element[0]
            )
            try:
                self.log.info("Input：" + input_element[1])
                self.engine.input(input_element[0], input_element[1])
                sleep(2)

            except Exception as e:
                raise Exception("Input Action Failed", e)

    def click(self, text):
        """
        Usage:
            execute click action
        :param text:
        :return:
        """
        click_elements = text[6:-1].split(",")
        for idx, el_text in enumerate(click_elements):
            el_text = el_text.strip().replace('"', "")
            self.log.info("Click：" + el_text)
            image = self.engine.auto_screenshot(self.image_dir)
            self.engine.draw_element(image, el_text)
            try:
                self.engine.click(el_text, image)
            except CUITestException as e:
                raise CUITestException("Click Element Failed, 无法找到：" + el_text, e)
            sleep(2)

    def swipe(self, text):
        valid_direction = ["down", "up", "left", "right"]
        swipe_text = text[6:-1].split(",")
        swipe_text = [el.strip().replace('"', "") for el in swipe_text]

        direction = swipe_text[0]
        swipe_length = swipe_text[1]

        swipe_times = swipe_text[2] if len(swipe_text) > 2 else 1

        if not any([valid_text == direction for valid_text in valid_direction]):
            self.log.critical(
                    "Error Swipe direction text, just support swipe up/down/left/right"
            )
            raise Exception("Error Swipe direction")

        for i in range(0, int(swipe_times)):
            if direction == "down":
                self.engine.swipe_down(distance=int(swipe_length))
            elif direction == "up":
                self.engine.swipe_up(distance=int(swipe_length))
            elif direction == "left":
                self.engine.swipe_left()
            elif direction == "right":
                self.engine.swipe_right()

    def url(self, text):
        """
        Usage:
            entry app activity by url scheme
        :param text: url scheme
        :return: None
        """
        self.engine.goto(text[4:-1])
        sleep(5)
        self.engine.handle_popup_window()
        sleep(2)


class TaskFlow:
    def __init__(self, uia_script, report, platform):
        """
        init a Task Flow
        :param uia_script: uia script file path
        """
        self.log = SimpleLog()
        self.uia_script = self.resourced(uia_script)
        self.config = ScriptParser(self.uia_script)
        self.steps = self.config.get_actions()
        self.report = report
        self.platform = platform

        if not AppiumParams.DEVICE_ID:
            if platform == Platform.Android:
                self.config.task_info.device_name = ADB.get_local_device()
            elif platform == Platform.IOS:
                self.config.task_info.device_name = IOSUiHelper.get_local_device()
        else:
            self.config.task_info.device_name = AppiumParams.DEVICE_ID

        self.log.info("AppiumPort: {port}".format(port=AppiumParams.APPIUM_PORT))
        self.log.info("UIAUTOMATOR2: {port}".format(port=AppiumParams.UIAUTOMATOR2PORT))

    @staticmethod
    def resourced(text):
        if text.startswith("http"):
            os.system("wget {text} -q".format(text=text))
            return os.path.basename(text)
        else:
            return text

    def start(self):
        """
        Usage:
            Start Task
            if one case failed, it will skip current case and execute next case
        :return: None
        """
        driver = None
        for action_case in self.steps:

            if not driver:
                # Appium Driver
                driver = AppiumClient(self.config.task_info, self.platform).start()

            # Execute Engine
            engine = EngineFactory(driver).create()

            # Android app start activity will changed, using this method can solve this.
            if self.config.task_info.root_url:
                engine.goto(self.config.task_info.root_url)

            sleep(5)

            try:
                script_execute = ScriptExecute(action_case, engine, self.report)
                script_execute.execute()
            except WebDriverException as e:
                self.log.critical("Execution Error, detail:" + e.args[0])
                driver.quit()
                driver = None
            except Exception as e:
                self.log.critical(e.args[0])
                print(e)
            finally:
                self.log.line_info("Start to Execute Next Test Case ---------->")
                sleep(5)

        resize_image_(self.report.image_dir)
        driver.quit()

    def debug(self):

        driver = AppiumClient(self.config.task_info, self.platform).start()

        # Execute Engine
        engine = EngineFactory(driver).create()

        # Android app start activity will changed, using this method can solve this.
        engine.goto(self.config.task_info.root_url)

        script_execute = ScriptExecute("", engine, self.report)
        ipt = ""

        while 1:
            try:
                ipt = input("=========== 输入需要执行的脚本，回车: ===========>: ")
                if ipt.lower() == "exit":
                    print("退出debug模式")
                    driver.quit()
                    exit()
            except KeyboardInterrupt as e:
                print("退出debug模式")
                driver.quit()
                exit()

            if ipt == "show":
                print("test", self.platform.lower(), Platform.Android.lower())
                if self.platform.lower() == Platform.Android.lower():
                    engine.activity.show_all_valid_elements()
                    # engine.activity.activity_overview()
                else:
                    print("iOS 不支持查看所有控件功能")

                print("\n\n")
                continue

            if ipt == "source":
                ipt = input("=========== 输入对象，回车: ===========>: ")
                el = engine.info_of(ipt)
                print(el)
                continue

            print("准备执行:")
            os.system("clear")

            if ipt.lower().strip() == "m":
                print("读取剪贴板内容，并执行")
                action_steps = clipboard.paste()
            else:
                print("读取输入数据，并执行")
                action_steps = ipt

            steps = action_steps.split("\n")

            print("\n".join(steps))
            print("\n\n")

            if not steps:
                print("请将你需要执行的语句复制到粘贴板,然后回车")
                continue

            for idx, action in enumerate(steps):
                try:
                    action = action.strip()
                    print(action)
                    script_execute.action_adapter(action)
                except Exception as e:
                    print(e)
