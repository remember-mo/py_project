# -*- coding: utf-8 -*-
# Copyright 2000-2017 by Koudai Corporation.
# All rights reserved.

# This software is the confidential and proprietary information of
# Koudai Corporation ("Confidential Information"). You
# shall not disclose such Confidential Information and shall use
# it only in accordance with the terms of the license agreement
# you entered into with Koudai.

# !/usr/bin/env python
# __author__ = 'hongkefeng'
import os
import time
from collections import Counter

import requests
from PIL import Image
from PIL import ImageDraw
from os import listdir
from functools import wraps
import errno
import os
import signal
from selenium.common.exceptions import WebDriverException


def ignore_exception(func):
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except DumpUiException as e:
            raise DumpUiException("appium server crashed", e.message)
        except WebDriverException as e:
            raise DumpUiException("appium server crashed", e.args[0])
        except TimeoutError as e:
            raise TimeoutError("get page source failed, re-connect appium", e.args[0])
        except Exception as e:
            print("------- ignore exception -------")
            print(e.__class__.__name__)
            print(e)
            print("------- ignore exception -------")

    return wrapper


class DumpUiException(Exception):
    def __init__(self, message, status):
        self.message = message
        self.status = status


def screenshot(driver, image_path):
    """
    :Usage:
        screen shot via appium driver

    : Why:
        just save image, don't do anything here, maybe make redirect image path
    in feature

    :param driver: the appium driver, should be Android or IOS appium driver
    :param image_path: the image directory path
    :return: return the screen shot image path
    """
    driver.save_screenshot(image_path)
    return image_path


def auto_screenshot(driver, image_dir, image_name=""):
    """
    :param image_name:
    :param image_dir:
    :Usage:
        screen shot via appium driver

    : Why:
        just save image, don't do anything here, maybe make redirect image path
    in feature

    :param driver: the appium driver, should be Android or IOS appium driver

    :return: return the screen shot image path
    """
    try:
        if not os.path.exists(image_dir):
            os.makedirs(image_dir)
        image_list = listdir(image_dir)
        image_name = image_name.replace('"', "")

        if image_name:
            image_path = os.path.join(
                    image_dir, str(len(image_list)) + "_action_" + image_name + ".png"
            )
        else:
            image_path = os.path.join(image_dir, str(len(image_list)) + "_.png")
        driver.save_screenshot(image_path)
        return image_path
    except Exception as e:
        print("auto screenshot failed", e)


def ios_draw_rectangle_on_element(
        image_path, element, new_file=False, color=True, plus=True
):
    """
    Usage:
        draw a rectangle on a element

    :param image_path: image path
    :param element: appium web element
    :param plus: is iPhone plus?
    :param new_file: draw a rectangle on a new image file
    :param color: boolean type, if True rectangle edge will be Blue or Red
    :return: None
    """

    try:
        x = element.location["x"] * 2
        y = element.location["y"] * 2
        height = element.size["height"] * 2
        width = element.size["width"] * 2
    except:
        x = element.center[0] * 2
        y = element.center[1] * 2
        height = element.center[2] * 2
        width = element.center[3] * 2

    if plus:
        x = x * 1.5
        y = y * 1.5
        height = height * 1.5
        width = width * 1.5

    draw_rectangle(image_path, (x, y), (x + width, y + height), new_file=new_file, color=color)


@ignore_exception
def resize_image_(image_path):
    try:
        img = Image.open(image_path)
        if img.size[0] > 100:
            base_width = img.size[0] / 2
            w_percent = base_width / float(img.size[0])
            h_size = int((float(img.size[1]) * float(w_percent)))
            img = img.resize((int(base_width), int(h_size)), Image.ANTIALIAS)
            img.save(image_path)
    except Exception as e:
        print("resize image failed：" + image_path, e)


def draw_android_element(fp, el, new_file=True, color=True, new_name="", bold=6):
    start = (el.center[0], el.center[1])
    end = (el.center[2], el.center[3])

    img_path = new_name if new_file else fp
    rgb = "blue" if color else "red"
    source_img = Image.open(fp)
    draw = ImageDraw.Draw(source_img)
    outline_width = bold
    draw.line((start, (start[0], end[1]), end), fill=rgb, width=outline_width)
    draw.line((start, (end[0], start[1]), end), fill=rgb, width=outline_width)
    source_img.save(img_path, "png")
    return img_path


@ignore_exception
def draw_rectangle(fp, start, end, new_file=True, color=True, new_name="", bold=6):
    """
    Usage:
        draw a rectangle on a image file

    :param fp: the image file path
    :param start: the left-top corner point (x, y)
    :param end: the right-bottom corner point (x, y)
    :param new_file: the new file path
    :param color: the rectangle edge color
    just two colors, if True Blue else Red
    :param new_name: if True, draw rectangle on a new image
    :param bold: rectangle edge bold, default is 10
    :return: the image file path which be draw
    """
    img_path = new_name if new_file else fp
    rgb = "blue" if color else "red"
    source_img = Image.open(fp)
    draw = ImageDraw.Draw(source_img)
    outline_width = bold
    draw.line((start, (start[0], end[1]), end), fill=rgb, width=outline_width)
    draw.line((start, (end[0], start[1]), end), fill=rgb, width=outline_width)
    source_img.save(img_path, "png")
    return img_path


def function_time_usage(func):
    def wrapper(*args, **kwargs):
        beg_ts = time.time()
        print("start exec func:" + func.__name__)
        retval = func(*args, **kwargs)
        end_ts = time.time()
        print("exec finished:" + func.__name__)
        print(func.__name__, "elapsed time: %f" % (end_ts - beg_ts))
        return retval

    return wrapper


def combine_images(image_dir, images=None, flag=True):
    if not images:
        if flag:
            image_list = [
                os.path.join(image_dir, f)
                for f in listdir(image_dir)
                if not f.startswith("action") and f.endswith("png")
            ]
        else:
            image_list = [os.path.join(image_dir, f) for f in listdir(image_dir)]

        if not image_list:
            return
    else:
        image_list = images

    images = map(Image.open, image_list)
    widths, heights = zip(*(i.size for i in images))

    total_width = sum(widths)
    max_height = max(heights)

    new_im = Image.new("RGB", (total_width, max_height))

    x_offset = 0
    for im in images:
        new_im.paste(im, (x_offset, 0))
        x_offset += im.size[0]

    number = str(len(listdir(image_dir)))

    final_image = os.path.join(os.path.dirname(image_list[0]), number + "_overview.png")
    new_im.save(final_image)

    for img in image_list:
        if not (img.__contains__("overview") or img.startswith("action")):
            os.remove(img)

    return final_image


def resize_image(image_dir):
    for path, subdirs, files in os.walk(image_dir):
        for name in files:
            if name.endswith("png") or name.endswith("jpg"):
                resize_image_(os.path.join(path, name))


@ignore_exception
def scale_image(input_image_path, width=1000, height=None):
    original_image = Image.open(input_image_path)
    w, h = original_image.size

    if width and height:
        max_size = (width, height)
    elif width:
        max_size = (width, h)
    elif height:
        max_size = (w, height)
    else:
        raise RuntimeError("Width or height required!")

    original_image.thumbnail(max_size, Image.ANTIALIAS)
    original_image.save(input_image_path)


class TimeoutError(Exception):
    pass


def timeout(seconds=10, error_message=os.strerror(errno.ETIME)):
    def decorator(func):
        def _handle_timeout(signum, frame):
            raise TimeoutError(error_message)

        def wrapper(*args, **kwargs):
            signal.signal(signal.SIGALRM, _handle_timeout)
            signal.alarm(seconds)
            try:
                result = func(*args, **kwargs)
            finally:
                signal.alarm(0)
            return result

        return wraps(func)(wrapper)

    return decorator


@ignore_exception
def upload_page_structure(driver, els, url, actions, app_version):
    els_text = [get_desc(i) for i in els]
    counter = Counter(els_text)
    result = sorted(counter.items())
    text = ",".join([str(i[0]) + str(i[1]) for i in result])
    activity = driver.current_activity

    images_path = auto_screenshot(driver, "tmp")
    resize_image_(images_path)
    image_url = upload_image(images_path, activity)
    data = {
        "appId": driver.capabilities["appPackage"],
        "activity": activity,
        "url": url,
        "actions": actions,
        "appVersion": app_version,
        "pageStructure": text,
        "imageUrl": image_url,
    }
    resp = requests.post(
            "http://uitest.daily.vdian.net/wdbuyer/activitys/",
            data=data,
            timeout=1
    )
    return resp


@ignore_exception
def upload_image(img, page_name):
    if page_name.startswith("."): page_name = page_name[1:]
    base_url = "http://uitest.daily.vdian.net/pages/{}/".format(page_name)
    resp = requests.post(
            "http://uitest.daily.vdian.net/wdbuyer/images/uploading",
            files={"file": open(img, "rb")},
            data={"isPageImage": True, "pageName": page_name},
    )

    if resp.status_code == 200:
        print("upload image succeeded", base_url + resp.json()["output"])
        return base_url + resp.json()["output"]
    else:
        print("upload image failed")
    return ""


def get_desc(el):
    if el.resource_id:
        return simple_text(el.resource_id)
    return simple_text(el.class_name)


def wait(func):
    def wrapper(*args, **kwargs):
        time.sleep(2)
        retval = func(*args, **kwargs)
        time.sleep(2)
        return retval

    return wrapper


def simple_text(text):
    text = text.replace("com.koudai.weidian.buyer", "package")
    text = text.replace("android.view.View", "View")
    text = text.replace("android.view.ViewGroup", "ViewGroup")
    text = text.replace("android.widget.FrameLayout", "FrameLayout")
    text = text.replace("android.widget.ImageView", "ImageView")
    text = text.replace("android.widget.LinearLayout", "LinearLayout")
    text = text.replace("android.widget.RelativeLayout", "RelativeLayout")
    text = text.replace("android:id", "id")
    text = text.replace("com.koudai.weidian.buyer:id", "id")
    text = text.replace("android.widget.TextView", "TextView")
    text = text.replace("package:id/", "")
    return text


def log(func):
    def wrapper(*args, **kwargs):
        print(10 * '-' + 'start --->' + func.__name__ + 10 * '-')
        retval = func(*args, **kwargs)
        print(10 * '-' + 'end ---->' + func.__name__ + 10 * '-')

        return retval

    return wrapper


if __name__ == "__main__":
    p = "/Users/weidian2015082404/PycharmProjects/Chimpanzee/Base/Task/images/搜索商品"
    # combine_images(p)

    # scale_image(input_image_path='src/report/images/1/overview.png',
    #             output_image_path='src/report/images/1/overview2.png',
    #             width=1000)

    # resize_image("src/report/images")
    # get_source()

    pass
