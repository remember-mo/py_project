# -*- coding: utf-8 -*-
# Copyright 2016 Weidian.com, Inc. or its affiliates. All Rights Reserved.
# This software is the confidential and proprietary information of
# Koudai Corporation ("Confidential Information"). You
# shall not disclose such Confidential Information and shall use
# it only in accordance with the terms of the license agreement
# you entered into with Koudai.

# !/usr/bin/env python
# __author__ = 'hongkefeng'

import json
import os
import re
from difflib import SequenceMatcher
from time import sleep
import subprocess
from appium.webdriver.common.touch_action import TouchAction
from pyappium.config import TaskConfig
from pyappium.log import SimpleLog
from pyappium.utils import timeout


class IOSUiHelper:
    """
    Usage:
        help user to find element friendly,
        just forgot appium find element method, such as:
        find_element_by_name, find_element_by_xpath,
        find_element_by_accessibility_id
        whatever. we provide one method "find_element" to replace
        appium several find element functions.

        it makes find element more easily
    """

    def __init__(
            self,
            appium_driver,
            url_service,
            popup_elements_json=TaskConfig.ios_popup_elements_json,
    ):
        """
        :param appium_driver: appium driver
        :param url_service: URL Scheme service
        :param popup_elements_json: popup elements
        """

        self.log = SimpleLog()
        self.driver = appium_driver
        self.url_service = url_service
        self.popup_elements_json_text = """
           {
             "popupElements": {
               "(closeButton)": "(closeButton)",
               "重新上线": "重新上线",
               "我知道了": "我知道了",
               "app update close button": "app update close button",
               "允许": "允许",
               "知道了": "知道了",
               "同意": "同意",
               "newIntroSkip": "newIntroSkip",
               "残忍滴拒绝": "残忍滴拒绝",
               "com.koudai.weishop.library.base:id/close_layout": "com.koudai.weishop.library.base:id/close_layout",
               "立即体验": "com.koudai.weishop.library.base:id/close_layout"
             }
           }"""
        self.log.line_info("Exception Popup File")
        if os.path.exists("popup.json"):
            self.log.info("popup json file detected, Using custom popup json file")
            self.popup_elements_json = json.load(open("popup.json"))["popupElements"]
        else:
            self.log.info(
                    "No popup_elements_json file, Using default popup element json file"
            )
            self.popup_elements_json = json.loads(self.popup_elements_json_text)[
                "popupElements"
            ]

        print(self.popup_elements_json)

    @staticmethod
    def abs_page(source):
        x = re.findall(">\n(\s+<\w+)", source)
        v = [val.strip().replace("<", str(val.count(" "))) for idx, val in enumerate(x)]
        z = [value for idx, value in enumerate(v[:-1]) if v[idx] != v[idx + 1]]
        return "".join(z)

    @staticmethod
    def diff_page(page1, page2):
        return SequenceMatcher(
                None, IOSUiHelper.abs_page(page1), IOSUiHelper.abs_page(page2)
        ).real_quick_ratio()

    def find_element(self, text):
        """Find element on IOS more easily
        :param text: it should be :
            - accessibility id
            - name
            - class
            - xpath
        :param exception_check: Type: Boolean
            True:
                when object not found, it will check the exception elements,
                if exception element found, click it. then find the object again
            False:
                when object not found
        :param search_log: Type: Boolean
            True: will show the search element log
            False: will not show the search element log
        :return:
            if object found, return appium web element
            if object not found, return None
        """
        text = text.replace('"', "")
        self.log.info("寻找控件: " + text)

        if TaskConfig.IOSCheckPopupWindowBeforeFindElement:
            self.popup_window_detect()

        if text.startswith("/"):
            try:
                return self.driver.find_element_by_xpath(text)
            except:
                return None

        try:
            return self.driver.find_element_by_accessibility_id(text)
        except:
            try:
                xpath = "//*[@name='{text}']".format(text=text)
                return self.driver.find_element_by_xpath(xpath)
            except Exception as e:
                return None

    def popup_window_detect(self, text=""):
        """
        Usage:
            check if is there a popup window on top activity
            if there is a popup window, handle it, and continue to
            find the target element.
        :param text: the target element text

        :return: the target element
        """
        # TODO
        self.log.info("popup_window_detect: " + text)
        # 处理无法找到控件的问题， 加载自动处理窗体设置
        source = self.get_source()
        # detect is there a popup element exists
        for key in self.popup_elements_json:
            if key in source:
                # click the popup elements
                self.log.warning("Exception Btn: ----> " + key)
                exception_btn = self.find_element_once(self.popup_elements_json[key])
                if exception_btn:
                    exception_btn.click()
                    sleep(2)
                    self.log.info("弹窗处理完成")
                    source = self.get_source()

        self.log.info("弹框处理完成")

        # TODO:
        if text:
            self.log.info("再次尝试寻找这个控件： " + text)
            return self.find_element_once(text)

    def find_element_once(self, text):
        """
        :return:
        """
        self.log.info("开始寻找 accessibility_id:" + text)

        text = text.replace('"', "")

        if text.startswith("/"):
            try:
                return self.driver.find_element_by_xpath(text)
            except Exception as e:
                return None

        if text.startswith("**"):
            fuzzy_text_xpath = "//*[contains(@name, '{}')]".format(text[2:])
            self.log.info("开始模糊寻找xpath:" + fuzzy_text_xpath)
            try:
                return self.driver.find_element_by_xpath(fuzzy_text_xpath)
            except Exception as e:
                print(e)
                return None
        try:
            return self.driver.find_element_by_accessibility_id(text)
        except:
            try:
                return self.driver.find_element_by_xpath(
                        '//*[@type="{text}"]'.format(text=text)
                )
            except Exception as e:
                print(e)
                return None

    def if_click(self, el):
        element = self.find_element_once(el)
        if element:
            element.click()

    def is_exist(self, text):
        return self.find_element_once(text)

    def find_elements(self, text):
        elements = None
        self.log.info("开始寻找:" + text)
        try:
            if text.startswith("/"):
                elements = self.driver.find_elements_by_xpath(text)
            else:
                elements = self.driver.find_elements_by_xpath(
                        '//*[@type="{text}"]'.format(text=text)
                )
        except Exception as e:
            self.log.error("无法找到对象:" + text)
        finally:
            self.log.info("找到对象:" + text)
            return elements

    @staticmethod
    def show_object(obj):
        try:
            el_info = " ".join(
                    [
                        "text:{text},".format(text=obj.text),
                        "tag_name: {tag_name},".format(tag_name=obj.tag_name),
                        "enabled: {enabled},".format(enabled=obj.is_enabled()),
                        "displayed:{displayed}".format(displayed=obj.is_displayed()),
                    ]
            )

        except Exception as e:
            print("获取元素信息失败")

    @staticmethod
    def element_to_string(ios_element, idx):
        if ios_element.name:
            return ios_element.name

        return ios_element.cls_name + " index: " + str(idx)

    def get_all_elements_info(self):
        all_elements_info = []
        el_text = self.clean_source(self.get_source())

        for text in el_text:
            name = ""
            el_type = re.findall(u'type="(\w+)"\s', text)[0]
            name_info = re.findall(u'name="(.+?)"\s', text)

            # 控件的文字描述
            if name_info:
                name = name_info[0]

            # 特殊的组件，比如iOS状态栏，等，不需要遍历
            if "XCUIElementTypeOther" in el_type:
                continue

            el_x = int(re.findall(u'x="([\d|-]+)"', text)[0])
            el_y = int(re.findall(u'y="([\d|-]+)"', text)[0])
            el_width = int(re.findall(u'width="([\d|-]+)"', text)[0])
            el_height = int(re.findall(u'height="([\d|-]+)"', text)[0])

            all_elements_info.append(
                    IOSElementInfo(el_type, el_x, el_y, el_height, el_width, name)
            )

        return all_elements_info

    def is_valid_element(self, el, el_info):
        # iOS 屏幕尺寸
        if el_info.y > 623:
            self.log.info("超出当前页面的元素")
            return False

        if "back" in el_info.name:
            self.log.info("可能是返回按钮")
            return False

        return True

    @staticmethod
    def clean_source(source):
        lines = []
        source_lines = source.split("\n")
        for i in source_lines:
            if not i.strip().startswith("</"):
                text = i.strip().replace(">/", "")[1:]
                if not ('x="0" y="0"' in text or "环境切换" in text):
                    info = re.findall("\W+\s?(type.+)", text)
                    if info[0].endswith("/>"):
                        lines.append(info[0][:-2])
                    else:
                        lines.append(info[0][:-1])
        return lines

    def draw_element(self, el):
        pass

    def get_source(self):
        try:
            return self.page_source()
        except TimeoutError as e:
            return self.page_source()

    @timeout(10, "get page source timeout")
    def page_source(self):
        return self.driver.page_source

    def go_activity(self, url):
        sleep(5)
        self.log.info("----- go activity ------")
        before_jump = self.get_source()
        self.url_service.jump_to_activity(url)
        sleep(1)
        for i in range(0, 3):
            after_jump = self.get_source()

            if after_jump == before_jump:
                sleep(5)
            else:
                break

    def click_element(self, el):
        before_click = self.get_source()
        el.click()
        sleep(2)
        after_click = self.get_source()

        if before_click == after_click:
            self.log.error("点击失败，页面没有变化")
            el.click()
        else:
            self.log.info("点击成功，页面有变化")

    @staticmethod
    def get_local_device():
        text = (
            subprocess.Popen(
                    "ios-deploy -l",
                    shell=True,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
            )
                .stdout.read()
                .strip()
        )
        device_id = re.findall("(\w{40})", str(text))
        return device_id[0]

    def swipe_up(self):
        self.driver.execute_script("mobile: scroll", {"direction": "up"})
        sleep(2)

    def swipe_down(self):
        self.driver.execute_script("mobile: scroll", {"direction": "down"})
        sleep(2)

    def swipe_left(self):
        self.driver.execute_script("mobile: scroll", {"direction": "left"})
        sleep(2)

    def swipe_right(self):
        self.driver.execute_script("mobile: scroll", {"direction": "right"})
        sleep(2)

    def get_screen_info(self):
        screen = self.driver.get_window_size()
        return screen, screen["width"], screen["height"]


class IOSElementInfo:
    def __init__(self, cls_name, x, y, height, width, name=""):
        self.cls_name = cls_name
        self.name = name
        self.x = x
        self.y = y
        self.height = height
        self.width = width
