# -*- coding: utf-8 -*-
# Copyright 2000-2017 by Koudai Corporation.
# All rights reserved.

# This software is the confidential and proprietary information of
# Koudai Corporation ("Confidential Information"). You
# shall not disclose such Confidential Information and shall use
# it only in accordance with the terms of the license agreement
# you entered into with Koudai.

# !/usr/bin/env python
# -*- coding: utf-8 -*-
# __author__ = 'hongkefeng'
import json
import os
import re
from time import sleep
from pyappium.config import TaskConfig
from pyappium.log import SimpleLog
from pyappium.utils import DumpUiException
from lxml import etree
from pyappium.utils import timeout, draw_rectangle, auto_screenshot


class AndroidUiHelper:
    """
        Usage:
        a friendly library of Android element search based appium driver
    """

    def __init__(self, driver):
        self.driver = driver
        self.log = SimpleLog()
        self.popup_elements_json_text = """
        {
             "popupElements":
             {
                 "重新上线": "重新上线",
                 "com.koudai.weishop.main:id/lib_update_id_close": "com.koudai.weishop.main:id/lib_update_id_close",
                 "app update close button":"app update close button",
                 "始终允许": "始终允许",
                 "总是允许": "总是允许",
                 "允许": "允许",
                 "我知道了": "我知道了",
                 "知道了": "知道了",
                 "同意": "同意",
                 "com.koudai.weishop.library.base:id/permisssion_ok_button": "com.koudai.weishop.library.base:id/permisssion_ok_button",
                 "newIntroSkip": "newIntroSkip",
                 "残忍滴拒绝": "残忍滴拒绝",
                 "com.koudai.weishop.library.base:id/close_layout": "com.koudai.weishop.library.base:id/close_layout",
                 "立即体验": "com.koudai.weishop.library.base:id/close_layout"
             }
         }
                    """

        self.log.line_info("Exception Popup File")
        if os.path.exists("popup.json"):
            self.log.info("popup json file detected, Using custom popup json file")
            self.popup_elements_json = json.load(open("popup.json"))["popupElements"]
        else:
            self.log.info("popup json file not detected, Using default popup json file")
            self.popup_elements_json = json.loads(self.popup_elements_json_text)[
                "popupElements"
            ]

    def find_element(self, text, exception_check=True, search_log=True):
        """
        Usage:
            a graceful method to find android element by one parameter.
            this method is instead to appium find_element_by_xxx.
            mostly you can use this method to find your element on
            activity.

        :param text:
            this param should be the following value
                - accessibility text
                - resource-id
                - content-desc
                - xpath
        :param exception_check:
                Type: Boolean
                if True: when element not found, it will check whether is a popup
                         activity exist
                if False: when element not found, do nothing

        :param search_log:
            Type: Boolean
                if True: when search element, it will show log on console and record to log file
                if False: no any log and console output
        :return:
            Type: Boolean
            if success, return appium web element
            if failed, return None
        """
        if search_log:
            self.log.info("Search Element: " + text)

        if TaskConfig.AndroidCheckPopupWindowBeforeFindElement:
            self.popup_window_detect()
            self.log.info("检测弹窗完成")

        target_element = None
        try:
            if text.startswith("/"):
                target_element = self.driver.find_element_by_xpath(text)
            elif ":id" in text:
                target_element = self.driver.find_element_by_id(text)
            else:
                xpath_sentence = '//*[@text="{text}" or @content-desc="{text}"]'.format(
                        text=text
                )
                target_element = self.driver.find_element_by_xpath(xpath_sentence)
        except Exception as e:
            self.log.error("Element not found ：{el_text}".format(el_text=text))
            if exception_check:
                target_element = self.popup_window_detect(text)
        return target_element

    def popup_window_detect(self, text="", task_screen=True):
        """
        Usage:
            check if is there a popup window on top activity
            if there is a popup window, handle it, and continue to
            find the target element.
        :param
            text: the target element text
            task_screen: true or false, if true, it will take a screen shot on handle popup element

        :return: the target element
        """
        # 处理无法找到控件的问题， 加载自动处理窗体设置
        exception_btn_imgs = []
        source = self.get_page_source().decode("utf-8")

        for key in self.popup_elements_json:
            if key in source:
                self.log.warning("Exception Btn: ----> " + key)
                exception_btn = self.find_element_once(self.popup_elements_json[key])

                if exception_btn:
                    if task_screen:
                        img = auto_screenshot(
                                driver=self.driver, image_dir="./src/report/images"
                        )
                        exception_btn_imgs.append(img)

                    exception_btn.click()
                    sleep(4)
                    self.log.info("弹窗处理完成")
                    source = self.get_page_source().decode("utf-8")
        if text:
            self.log.info("再次尝试寻找这个控件： " + text)
            # 处理完弹窗以后，再次寻找这个对象
            return self.find_element(text, exception_check=False)
        return exception_btn_imgs

    @timeout(10, "get page source timeout")
    def page_source(self):
        source = self.driver.page_source.encode("utf-8")
        etree.fromstring(
                source,
                parser=etree.XMLParser(ns_clean=True, recover=True, encoding="utf-8"),
        )
        return source

    def get_page_source(self):
        try:
            return self.page_source()
        except TimeoutError as e:
            print(e)
            return self.page_source()

    def find_element_once(self, text):
        text = text.replace('"', "")
        self.log.info("find element once: " + text)
        if text.startswith("/"):
            try:
                return self.driver.find_element_by_xpath(text)
            except Exception as e:
                return None

        if ":id" in text:
            try:
                return self.driver.find_element_by_id(text)
            except Exception as e:
                return None

        if text in ["unloginCloseBtn"]:
            try:
                return self.driver.find_element_by_id(text)
            except Exception as e:
                return None

        try:
            xpath_sentence = '//*[@text="{text}" or @content-desc="{text}"]'.format(
                    text=text
            )
            return self.driver.find_element_by_xpath(xpath_sentence)
        except Exception as e:
            return None

    def if_click(self, el):
        element = self.find_element_once(el)
        if element:
            element.click()


class Activity:
    def __init__(self, driver):
        self.log = SimpleLog()
        self.driver = driver
        self.name = driver.current_activity
        self.package = driver.desired_capabilities["appPackage"]
        self.parser = etree.XMLParser(recover=True)

    def enum_all_elements(self):

        page_source = self.get_page_source()
        if not page_source:
            self.log.error("parse dump xml failed")
            raise DumpUiException("dump xml failed", "get page source failed")

        elements = []
        parser = etree.XMLParser(ns_clean=True, recover=True, encoding="utf-8")
        tree = etree.fromstring(page_source, parser=parser)
        all_descendants = list(tree.iter())

        for node in all_descendants:
            for element in node:
                class_name = element.attrib["class"]
                resource_id = element.attrib["resource-id"]
                text = element.attrib["text"]
                desc = element.attrib["content-desc"]
                bounds = element.attrib["bounds"]
                clickable = element.attrib["clickable"]
                enabled = element.attrib["enabled"]
                scrollable = element.attrib["scrollable"]
                location = re.findall("\[(\d+),(\d+)\]", bounds)
                bounds = (
                    (int(location[1][0]) - int(location[0][0])) / 2
                    + int(location[0][0]),
                    (int(location[1][1]) - int(location[0][1])) / 2
                    + int(location[0][1]),
                )
                xpath = ""

                if class_name or text or desc:
                    element = Element(
                            class_name=class_name,
                            text=text,
                            resource_id=resource_id,
                            desc=desc,
                            bounds=bounds,
                            center=(
                                int(location[0][0]),
                                int(location[0][1]),
                                int(location[1][0]),
                                int(location[1][1]),
                            ),
                            clickable=clickable,
                            enabled=enabled,
                            scrollable=scrollable,
                            xpath=xpath,
                    )
                    elements.append(element)
        return elements

    def find_element_ex(self, el):
        all_elements = self.enum_all_elements()
        for element in all_elements:
            if el == element.text or el == element.desc or el == element.resource_id:
                return element
        else:
            return None

    def find_element_fuzzy(self, el):
        all_elements = self.enum_all_elements()
        for element in all_elements:
            if el in element.text or el in element.desc or el == element.resource_id:
                return element
        else:
            return None

    @timeout(10, "get page source timeout")
    def page_source(self):
        source = self.driver.page_source.encode("utf-8")
        etree.fromstring(
                source,
                parser=etree.XMLParser(ns_clean=True, recover=True, encoding="utf-8"),
        )
        return source

    def get_page_source(self):
        try:
            return self.page_source()
        except Exception as e:
            print(e)
            self.log.warning("parse dump ui xml exception")

    def enum_all_valid_elements(self):
        all_elements = self.enum_all_elements()
        valid_els = list(
                filter(
                        lambda el: el.clickable == "true"
                                   and el.enabled == "true"
                                   and el.class_name != "android.webkit.WebView",
                        all_elements,
                )
        )

        # this is not a finally solution,do not handle the webview element
        if len(valid_els) > 50:
            return valid_els[:50]

        return valid_els

    def enum_all_visible_elements(self):
        all_elements = self.enum_all_elements()
        valid_els = list(
                filter(
                        lambda el: el.enabled == "true"
                                   and el.class_name != "android.webkit.WebView",
                        all_elements,
                )
        )
        return valid_els

    def show_all_valid_elements(self):
        els = self.enum_all_visible_elements()
        for i in els:
            if i.text or i.desc or i.resource_id:

                if i.resource_id:
                    print(i.resource_id)
                else:
                    print(i.class_name)

        return els

    def click(self, el, adb):
        el = el.strip()
        element = self.find_element_ex(el)

        if element:
            element.click(adb)

    def activity_overview(self, image_dir="./overview/"):
        self.log.info("生成被测试页面总览图")
        all_control = 0
        activity_image = auto_screenshot(self.driver, image_dir)
        all_els = self.enum_all_valid_elements()
        all_control += len(all_els)
        self.log.info("这个页面一共有{total}个控件需要遍历".format(total=all_control))
        for el in all_els:
            try:
                draw_rectangle(
                        activity_image,
                        (el.center[0], el.center[1]),
                        (el.center[2], el.center[3]),
                        new_file=False,
                )
            except Exception as e:
                print(e)


class Element:
    def __init__(
            self,
            class_name="",
            text="",
            resource_id="",
            desc="",
            bounds=(0, 0),
            center=(0, 0, 0, 0),
            xpath="",
            clickable=False,
            enabled=False,
            scrollable=False,
    ):
        self.class_name = class_name
        self.text = text
        self.resource_id = resource_id
        self.desc = desc
        self.bounds = bounds
        self.center = center
        self.clickable = clickable
        self.enabled = enabled
        self.scrollable = scrollable
        self.xpath = xpath

    def click(self, adb):
        adb.shell("input tap " + str(self.bounds[0]) + " " + str(str(self.bounds[1])))

    @property
    def info(self):
        if self.text:
            return self.text

        if self.resource_id:
            return self.resource_id

        if self.desc:
            return self.desc
