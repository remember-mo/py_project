# !/usr/bin/env python
# -*- coding: utf-8 -*-
# __author__ = 'hongkefeng'

# Copyright 2000-2017 by Koudai Corporation.
# All rights reserved.
# This software is the confidential and proprietary information of
# Koudai Corporation ("Confidential Information"). You
# shall not disclose such Confidential Information and shall use
# it only in accordance with the terms of the license agreement
# you entered into with Koudai.
import os
import time
import requests
from time import sleep

from appium.webdriver.common.touch_action import TouchAction
from selenium.common.exceptions import WebDriverException
from pyappium.log import SimpleLog
from pyappium.utils import resize_image, DumpUiException, upload_page_structure
from pyappium.report import Report
from pyappium.script_parser import (
    TaskInfo,
    ADB,
    IOSUiHelper,
    IOSUrlService,
)
from pyappium.engine import EngineFactory
from pyappium.appium_client import AppiumClient
from pyappium.zeus_params import AppiumParams
from pyappium.config import *
import pkgutil


class TaskEngine(object):
    __RESULT_FAILED = "failed"
    __RESULT_PASSED = "passed"
    __TASK_APP_VERSION = ""

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.__finished()

    def __init__(self, package, root_url, start_activity, platform):
        self.log = SimpleLog()

        self.task_info = TaskInfo()
        self.task_info.root_url = root_url
        self.task_info.package = package
        self.task_info.activity = start_activity
        self.platform = platform

        self.engine = None
        self.activity = None
        self.report = Report("./src/report", "report")
        self.__image_dir = ""
        self.__case_name = ""
        self.app_version = ""
        self.width = 0
        self.height = 0
        if not AppiumParams.DEVICE_ID:
            if self.platform.lower() == Platform.Android.lower():
                self.task_info.device_name = ADB.get_local_device()
            elif self.platform.lower() == Platform.IOS.lower():
                self.task_info.device_name = IOSUiHelper.get_local_device()
        else:
            self.task_info.device_name = AppiumParams.DEVICE_ID

        driver = AppiumClient(self.task_info, self.platform.title()).start()
        self.engine = EngineFactory(driver).create()
        self.engine.goto(self.task_info.root_url)
        self.driver = driver
        sleep(5)

    def click(self, *args):
        ts = time.time()
        click_actions_images = []
        for element in args:
            self.log.info("点击元素: " + element)
            el_desc = element.replace('"', "").replace("/", "-")
            image = self.engine.auto_screenshot(self.__image_dir)
            self.engine.draw_element(image, element)

            try:
                self.engine.click(element)
                # 点击操作应该有个等待时间
                sleep(3)
                click_actions_images.append(os.path.basename(image))
            except DumpUiException:
                self.log.warning("appium server error， restart appium")
                driver = AppiumClient(self.task_info, self.platform.title()).start()
                self.engine = EngineFactory(driver).create()
                self.engine.goto(self.task_info.root_url)
                self.driver = driver
                sleep(5)
            except Exception as e:
                self.log.error("点击对象失败：")
                self.add_test_case(
                        "failed",
                        "点击控件失败: " + element,
                        "0",
                        "无法找到对象: " + element,
                        [os.path.basename(image)],
                )
                break
        else:
            te = time.time()
            # combine_images(self.image_dir, click_actions_images, False)
            info = "点击控件: " + "  ,  ".join(args)
            self.add_test_case(
                    "passed",
                    info[:100],
                    str(te - ts)[:6],
                    "点击控件: " + "  ,  ".join(args),
                    click_actions_images,
            )

    def add_screenshot(self, description):
        image = self.engine.auto_screenshot(self.__image_dir)
        self.add_test_case(
                "passed", description, "0", description, [os.path.basename(image)]
        )

    def info_of(self, text):
        return self.engine.info_of(text)

    def is_exist(self, text):
        return self.engine.info_of(text)

    def swipe_down(self, times=1, distance=800):
        for i in range(times):
            sleep(1)
            self._swipe("down", distance)
        self.add_simple_case("pass", "向下滑动完成 :{}次".format(times), "swipe_down")

    def swipe_up(self, times=1, distance=800):
        for i in range(times):
            sleep(1)
            self._swipe("up", distance)

        self.add_simple_case("pass", "向上滑动完成 :{}次".format(times), "swipe_up")

    def swipe_left(self):
        self.engine.swipe_left()

    def swipe_right(self):
        self.engine.swipe_right()

    def _swipe(self, direction, distance):
        if direction == "down":
            self.engine.swipe_down(distance)
        else:
            self.engine.swipe_up(distance)

    def exist(self, *args):
        for check_element in args:
            image = self.engine.auto_screenshot(self.__image_dir, "exist")
            self.engine.draw_element(image, check_element)

            ts = time.time()
            if self.engine.verify_exist(check_element):
                self.log.info("找到控件: " + check_element)
                result = "passed"
                info = "找到控件：" + check_element
                te = time.time()
                self.add_test_case(
                        result,
                        "验证控件[{}]是否存在".format(check_element),
                        str(te - ts)[:6],
                        info,
                        os.path.basename(image),
                )
            else:
                self.log.error("没有找到控件: " + check_element)
                result = "failed"
                info = "没有找到：" + check_element
                te = time.time()
                self.add_test_case(
                        result,
                        "没有找到{}控件".format(check_element),
                        str(te - ts)[:6],
                        info,
                        os.path.basename(image),
                )

    def not_exist(self, *args):
        for check_element in args:
            image = self.engine.auto_screenshot(self.__image_dir, "exist")
            self.engine.draw_element(image, check_element)
            ts = time.time()
            if self.engine.verify_exist(check_element):
                self.log.error("不应该找到控件: " + check_element)
                self.__add_verify_not_exist("failed",
                                            check_element,
                                            "控件{}不应该存在：".format(check_element),
                                            time.time(),
                                            ts,
                                            image)
            else:
                self.log.info("验证控件不应该存在: " + check_element)
                self.__add_verify_not_exist("passed",
                                            check_element,
                                            "没有找到：{}".format(check_element),
                                            time.time(),
                                            ts,
                                            image)

    def __add_verify_not_exist(self, result, check_element, info, te, ts, image):
        self.add_test_case(
                result,
                "验证控件[{}]不应该存在".format(check_element),
                str(te - ts)[:6],
                info,
                os.path.basename(image),
        )

    def fuzzy_exist(self, text):
        image = self.engine.auto_screenshot(self.__image_dir)
        if text in self.driver.page_source:
            self.add_test_case(
                    "passed",
                    "模糊校验，找到元素:{}".format(text),
                    "0.0",
                    "模糊校验，找到元素:{}".format(text),
                    os.path.basename(image)
            )
            return True
        else:
            self.add_test_case(
                    "failed",
                    "模糊校验，未到元素:{}".format(text),
                    "0.0",
                    "模糊校验，未到元素:{}".format(text),
                    os.path.basename(image)
            )
            return False

    def fuzzy_not_exist(self, text):
        image = self.engine.auto_screenshot(self.__image_dir)
        if text in self.driver.page_source:
            self.add_test_case(
                    "failed",
                    "模糊校验，找到元素:{}".format(text),
                    "0.0",
                    "模糊校验，找到元素:{}".format(text),
                    os.path.basename(image)
            )
            return False
        else:
            self.add_test_case(
                    "passed",
                    "模糊校验，找到元素:{}".format(text),
                    "0.0",
                    "模糊校验，找到元素:{}".format(text),
                    os.path.basename(image)
            )
            return True

    def restart_app(self):
        self.log.info("restart_app")
        self.engine.restart_app()

    def press_center(self):
        if self.platform.lower() == Platform.Android.lower():
            if self.width == 0:
                self.width = self.get_screen_width()
                self.height = self.get_screen_height()

            self.engine.adb.tap(int(self.width) / 2, int(self.height) / 2)
        else:
            self.log.warning("iOS does not support this function for now")

    def url(self, url):
        self.engine.goto(url)
        sleep(2)

        img = self.engine.auto_screenshot(self.__image_dir)
        self.add_test_case(
                "passed", "进入页面: " + url, "0.0", "进入: " + url, os.path.basename(img)
        )
        exception_elements = self.engine.handle_popup_window()
        if exception_elements:
            for img in exception_elements:
                self.add_test_case("passed", "处理异常弹框", "0.0", "", os.path.basename(img))
        sleep(2)

        # self.upload_activity_info(url)

    def upload_activity_info(self, url):
        if Platform.Android.lower() == self.platform.lower():
            upload_page_structure(
                    driver=self.driver,
                    els=self.engine.activity.enum_all_visible_elements(),
                    url=url,
                    actions=[],
                    app_version=self.__get_test_app_version()
            )

    def long_click(self, text, press_time):
        element = self.engine.uihelper.find_element(text)
        actions = TouchAction(self.driver)
        actions.long_press(element, duration=press_time).wait(press_time).perform()
        time.sleep(press_time)

    def iclick(self, *args):
        [self.log.info("iclick:" + i) for i in args]
        images = self.engine.iclick(args, self.__image_dir)

        for img in images:
            self.add_test_case(
                    "passed", "点击可能的控件" + ", ".join(args), "0.0", "", os.path.basename(img)
            )

    def __get_test_app_version(self):
        if not self.__TASK_APP_VERSION:
            self.__TASK_APP_VERSION = self.engine.adb.get_app_version(
                    self.task_info.package
            )
        return self.__TASK_APP_VERSION

    def input(self, element_info, text):
        sleep(1)
        try:
            ts = time.time()
            self.engine.input(element_info, text)
            te = time.time()
            img = self.engine.auto_screenshot(self.__image_dir)
            self.engine.draw_element(img, element_info)
        except Exception as e:
            img = self.engine.auto_screenshot(self.__image_dir)
            self.add_test_case(
                    "failed", "输入：" + text, "0.0", e.args[0], os.path.basename(img)
            )
        else:
            self.add_test_case(
                    "passed",
                    "输入文字: " + text,
                    str(te - ts)[:6],
                    "输入：" + text,
                    os.path.basename(img),
            )

    def __finished(self):
        self.log.info("正在压缩图片")
        resize_image(self.report.image_dir)
        self.log.info("压缩图片完成，准备退出Appium")

        if self.platform.lower() == Platform.Android.lower():
            self.log.info("恢复输入法")
            self.engine.adb.recover_ime()

        if self.engine.driver:
            self.engine.driver.quit()

    def add_test_group(self, case_name):
        self.log.line_info("开始执行：" + case_name)
        self.report.add_test_activity(case_name)
        self.__case_name = case_name
        self.__image_dir = os.path.join(AppiumParams.REPORT_DIR, "images", case_name)
        if not os.path.exists(self.__image_dir):
            os.makedirs(self.__image_dir)

    def add_test_case(self, result, title, duration, detail, image_check_element):
        self.report.add_test_case(
                result, title, duration, detail, self.__get_image_path(image_check_element)
        )

    def add_simple_case(self, result, title, image=""):
        if image:
            image = self.engine.auto_screenshot(self.__image_dir, image)
            self.add_test_case(result, title, "0.0", "", os.path.basename(image))
        else:
            self.add_test_case(result, title, "0.0", "", [])

    def __get_image_path(self, img_name):
        image_list = []
        image_relative_path = "./images/{case}/{img_name}"
        if isinstance(img_name, list):
            for i in img_name:
                image_list.append(
                        image_relative_path.format(case=self.__case_name, img_name=i)
                )
        else:
            image_list.append(
                    image_relative_path.format(case=self.__case_name, img_name=img_name)
            )
        return image_list

    @staticmethod
    def set_popup_elements(popup_elements):
        if popup_elements.startswith("http"):
            if os.path.exists("popup.json"):
                os.remove("popup.json")
            os.system("wget -O popup.json {0} -q".format(popup_elements))

    def get_elements_by_id(self, elements_id):
        """
        return all elements id equals elements_id
        :param elements_id: android/ios resource-id
        :return: appium WebElement list
        """
        return self.engine.driver.find_elements_by_id(elements_id)

    def get_elements_by_class(self, class_name):
        """
        return all elements class_name equals class_name
        :param class_name: android/ios element class name
        :return: appium WebElement list
        """
        return self.engine.driver.find_elements_by_class_name(class_name)

    @staticmethod
    def wait(times=2):
        sleep(times)

    def run(self, *classes, **kwargs):
        __before_class = "before_class"
        __before = "before"
        __after_class = "after_class"
        __after = "after"
        __test_key_word = "test"
        __testcase_key_word = "testcase"

        if kwargs.get(__testcase_key_word):
            classes = kwargs[__testcase_key_word]

        for test_class in classes:
            # exec before_class method if before_class exists
            if hasattr(test_class, __before_class):
                self.log.line_info(__before_class)
                try:
                    getattr(test_class, __before_class)(self)
                except DumpUiException as e:
                    self.__restart_appium()

            for testcase in dir(test_class):
                func_args = ()
                try:
                    func_args = getattr(test_class, testcase).__code__.co_varnames
                except:
                    pass

                if __test_key_word in func_args:
                    try:
                        # exec the before function
                        if hasattr(test_class, __before):
                            self.log.line_info(__before)
                            getattr(test_class, __before)(self)

                        # exec the test function
                        getattr(test_class, testcase)(self)

                        # exec after function in class
                        if hasattr(test_class, __after):
                            self.log.line_info(__after)
                            getattr(test_class, __after)(self)
                    except DumpUiException as e:
                        self.__reconnect_appium(testcase)
                    except WebDriverException as e:
                        self.__reconnect_appium(testcase)
                    except TimeoutError as e:
                        self.__reconnect_appium(testcase)
                    except Exception as e:
                        self.add_simple_case(self.__RESULT_FAILED, "不可控异常，请检查脚本执行情况")

            # exec after_class method if after_class exists
            if hasattr(test_class, __after_class):
                self.log.line_info(__after_class)
                try:
                    getattr(test_class, __after_class)(self)
                except DumpUiException as e:
                    self.__restart_appium()

    def __reconnect_appium(self, testcase):
        self.__restart_appium()
        self.add_test_case(
                self.__RESULT_FAILED,
                "{} Appium 异常，本脚本未执行完成, 重启Appium，继续执行".format(testcase),
                "0.0",
                "Appium异常，请排查原因",
                [],
        )

    def __restart_appium(self):
        self.log.warning("appium server error， re-connect to appium")
        self.driver = AppiumClient(self.task_info, self.platform.title()).start()
        self.engine = EngineFactory(self.driver).create()
        sleep(5)

    def run_all(self, testcase=None):
        self.log.line_info("Run All")
        pkg_list = [
            modname
            for importer, modname, ispkg in pkgutil.iter_modules(testcase.__path__)
        ]
        module_list = [
            (__import__("{}.{}".format("testcase", module)), module)
            for module in pkg_list
        ]
        all_module = [(getattr(i, j)) for i, j in module_list]
        self.log.line_info("Task List:")
        [self.log.info(j) for i, j in module_list]
        self.run(testcase=all_module)

    def scroll_down_to(self, text, max_scroll=5):
        """
        直接向下滚动，直到找到 text 元素
        :param text:
        :param max_scroll:
        :return:
        """
        self.log.info("滚动到元素：{}".format(text))
        while max_scroll >= 0:
            if self.engine.verify_exist(text):
                return
            max_scroll = max_scroll - 1
            self._swipe("down", 800)
            time.sleep(1)

    def scroll_down_click(self, text, max_scroll=5):
        """
        直接向下滚动，直到找到 text 元素, 然后点击这个元素
        :param text:
        :param max_scroll:
        :return:
        """
        self.log.info("滚动到元素：{}".format(text))
        while max_scroll >= 0:
            if self.engine.verify_exist(text):
                self.click(text)
                return
            max_scroll = max_scroll - 1
            self._swipe("down", 800)
            time.sleep(1)

    def scroll_to(self, text, max_scroll=5):
        """
        先滚动到顶部，在从上到下查找指定的元素
        :param text: 被查找的元素
        :param max_scroll: 向下滚动的次数
        :return:
        """
        self.log.info("先滚动到顶部")
        self.swipe_up(3, 1000)

        self.log.info("滚动到元素：{}".format(text))
        while max_scroll >= 0:
            if self.engine.verify_exist(text):
                return
            max_scroll = max_scroll - 1
            self.swipe_down()
            time.sleep(1)

    def get_screen_width(self):
        return self.engine.driver.get_window_size()["width"]

    def get_screen_height(self):
        return self.engine.driver.get_window_size()["height"]

    def press_back(self):
        if self.platform.lower() == Platform.Android.lower():
            self.log.info("press back key")
            self.engine.press_back()
        else:
            self.log.warning("iOS does not support this function for now")

    @staticmethod
    def get_user_input_module(package_name, args):
        pkg_list = [
            modname for importer, modname, ispkg in pkgutil.iter_modules(package_name.__path__)
        ]
        module_list = [
            (__import__("testcase.{}".format(module)), module) for module in pkg_list
        ]
        return [(getattr(i, j)) for i, j in module_list if j in args.run.split(",")]


def test(func):
    def wrapper(*args, **test):
        return func(*args, **test)

    return wrapper
